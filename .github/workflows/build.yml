name: Build Tauri App

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allow manual triggering

env:
  CARGO_TERM_COLOR: always

jobs:
  build-tauri:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: ubuntu-latest
            targets: "deb, appimage" # Build x64 Linux targets
            artifact_suffix: linux-x64
          - platform: ubuntu-latest # Use ubuntu for ARM cross-compile
            targets: "deb_arm64, appimage_arm64" # Build ARM64 Linux targets
            artifact_suffix: linux-arm64
            cross_compile: true # Flag for cross-compilation steps
          - platform: macos-latest # Use macos-13 for universal builds if needed, macos-latest is usually fine
            targets: "app, dmg" # Build Universal macOS target (includes x64 and arm64)
            artifact_suffix: macos-universal
          - platform: windows-latest
            targets: "nsis, msi" # Build Windows x64 targets
            artifact_suffix: windows-x64

    runs-on: ${{ matrix.platform }}
    name: Build Tauri (${{ matrix.artifact_suffix }})

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js from .nvmrc
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Set up pnpm from package.json
        uses: pnpm/action-setup@v3
        with:
          # Reads version from package.json: "pnpm@9.1.4" -> "9.1.4"
          version: ${{ fromJson(steps.read-package-json.outputs.packageJson).packageManager | split('@') | last() }}
          run_install: false

      # Step to read package.json needed for pnpm version extraction above
      - name: Read package.json
        id: read-package-json
        uses: juliangruber/read-file-action@v1
        with:
          path: ./package.json

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install frontend dependencies
        run: pnpm install --frozen-lockfile

      # Optional: Build frontend if needed separately (tauri-action usually handles this)
      # - name: Build frontend
      #   run: pnpm build

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust dependencies (Cargo)
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: ./src-tauri -> target # Cache target dir for src-tauri workspace

      # Install Linux dependencies (including ARM cross-compiler if needed)
      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.0-dev \
              build-essential \
              curl \
              wget \
              file \
              libssl-dev \
              libgtk-3-dev \
              libayatana-appindicator3-dev \
              librsvg2-dev \
              ${{ matrix.cross_compile && 'gcc-aarch64-linux-gnu g++-aarch64-linux-gnu' || '' }} # Install cross-compile tools only if needed

      # Add ARM Rust target for cross-compilation on Linux runner
      - name: Add ARM64 Rust target
        if: matrix.cross_compile && matrix.platform == 'ubuntu-latest'
        run: rustup target add aarch64-unknown-linux-gnu

      # Set linker for ARM64 cross-compilation on Linux runner
      - name: Set ARM64 Linker Env Var
        if: matrix.cross_compile && matrix.platform == 'ubuntu-latest'
        run: echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV

      - name: Build Tauri app using tauri-action
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }} # Uncomment if needed for signing
          # TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }} # Uncomment if needed for signing
        with:
          projectPath: ./ # Root of the project
          # distPath: ./dist # Uncomment if frontend build output is not './dist'
          # iconPath: ./src-tauri/icons/icon.png # Uncomment if icon path is different
          tauriScript: pnpm tauri # Command to run Tauri CLI build
          targets: ${{ matrix.targets }}
          args: --verbose # Add verbosity to build logs

      # Create artifact name (e.g., app-linux-x64, app-macos-universal)
      - name: Set artifact name
        id: artifact_name
        shell: bash
        run: |
          # Extract app name from package.json (optional, fallback to 'app')
          APP_NAME=$(jq -r .name package.json || echo "app")
          echo "NAME=${APP_NAME}-${{ matrix.artifact_suffix }}" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact_name.outputs.NAME }}
          # Adjust paths based on actual tauri-action output structure
          # This covers common outputs for the specified targets
          path: |
            src-tauri/target/release/bundle/deb/*.deb
            src-tauri/target/release/bundle/appimage/*.AppImage
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/dmg/*.dmg
            src-tauri/target/release/bundle/macos/*.app
          if-no-files-found: error # Error if build output is missing
